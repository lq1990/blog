---
title: 握手与挥手
date: 2020-02-22 13:26:07
tags: 计算机网络
---

# TCP连接的建立和释放（握手与挥手）

## 三次握手
本质上是建立一次连接，发送3次报文。

![](/images/计算机网络/三次握手.png)
1. 客户机向服务器发送报文，报文头包含SYN=1,seq=x。该报文发送到服务器。
2. 服务器此前已经被动打开处于 LISTEN 状态，当服务器收到来自客户机的报文后，它会立刻向客户机发送确认报文 此报文头包含SYN=1,ACK=1,seq=y,ack=x+1
3. 客户机收到报文，客户端再发送一次握手的报文，此报文也是确认报文，是客户机确认已经收到了服务器收到了确认。简而言之：客户端确认了服务器的确认。
   报文头包含ACK=1,seq=x+1,ack=y+1。发现此处seq=x+1和 第一次发送的seq=x 差1，说明这两个报文直接相连，两者之间没有其它报文。
到此，两者建立了连接。进行数据传送。

注：
  - 报文都有seq序列号，递增的
  - ACK是确认位，当ACK=1代表此报文有效，当ACK=0代表报文无意义
  - ack: 小写ack代表ACK字段的值

问题：
  有了第1和2，就可以建立客户机和服务器联系了，为什么还需要第3即再次发送确认呢？
答案：
  由于阻塞等原因，使得client发送的某次报文滞留，client会超时重发一个同样的，而此时问题产生，即上次滞留的报文不在阻塞和这次重发的报文 有可能都向服务器发送，若没有第3步，则会建立两个连接，其中一个是冗余的。有了第3步，则滞留的那个报文会被失效。

## 四次挥手
![](/images/计算机网络/四次挥手.png)
1. 客户端和服务器处于连接状态
2. 当客户机主动关闭时，向服务器发送报文 头部信息FIN=1,seq=u
3. 服务器收到报文，服务器向客户机发送报文
   --- 到此为止，客户机已经停止，客户机此时无法再向服务器发送报文 ---
4. 当客户机关闭后，服务器有可能还有要继续处理的任务还需要往客户发送数据，在服务器关闭前还有数据要发送给客户。当服务器要关闭时，服务器向客户发送报文 头部信息是FIN=1,ACK=1,seq=w,ack=u+1。注意到seq=w，而不是seq=v+1，因为在两个seq之间还有别的数据发送。
5. 客户机收到服务器的报文，客户向服务器发送报文 头部信息ACK=1,seq=u+1,ack=w+1
到此，两者都关闭。

注：
  - 客户发送的两次报文头部的seq=u和seq=u+1。说明这两次报文是连续的。

问题：
  为什么客户机最后在关闭前，还要TIME-WAIT
解答：
  最后一次客户机发送给服务器的确认 有可能服务器收不到，服务器会认为是他自己没有把报文发出去，此时服务器会再次发送报文（我要关闭了）。
  因此只有最后客户需要等待一会。
  

对于四次挥手的拟人化理解：
1. 客户机：我要断开了
2. 服务器：好的，你断开吧。
3. 服务器：我要断开了
4. 客户机：好的，你断开吧。

# 参考
https://www.bilibili.com/video/av69145968?from=search&seid=7890701730735260547

